{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Language Overview Go, commonly written as Golang, is a type-safe language that excels at concurrency, websocket, and gRPC implementations. Go fits well with most API use cases, especially when heavy load begs for concurrent operations. Go is also supported for AWS Lambda functions. The language sports a robust set of native libraries including a simple-to-use http library, a generic sql interface (supplemented by a database-specific driver library), crypto functions, and more. Simple APIs can be built quickly from just built-in packages. Since Go can be compiled to WebAssembly , it is possible to build Go modules to be run in the browser. To get started The workshop repository with hands-on examples is here with setup instructions. Workshop Structure The 'Basics' module starts with the components that you will see across most common languages then delves into 'Intermediate' where we explore the concepts and structures that set Go apart. The 'Advanced' module builds on those concepts and introduces several new built-in components. The intended flow of the workshop is to go through each module's presentation on the site one part at a time and then complete the TODOs in the associated exercise. The code can be run via the Makefile for simplicity.","title":"Home"},{"location":"#language-overview","text":"Go, commonly written as Golang, is a type-safe language that excels at concurrency, websocket, and gRPC implementations. Go fits well with most API use cases, especially when heavy load begs for concurrent operations. Go is also supported for AWS Lambda functions. The language sports a robust set of native libraries including a simple-to-use http library, a generic sql interface (supplemented by a database-specific driver library), crypto functions, and more. Simple APIs can be built quickly from just built-in packages. Since Go can be compiled to WebAssembly , it is possible to build Go modules to be run in the browser.","title":"Language Overview"},{"location":"#to-get-started","text":"The workshop repository with hands-on examples is here with setup instructions.","title":"To get started"},{"location":"#workshop-structure","text":"The 'Basics' module starts with the components that you will see across most common languages then delves into 'Intermediate' where we explore the concepts and structures that set Go apart. The 'Advanced' module builds on those concepts and introduces several new built-in components. The intended flow of the workshop is to go through each module's presentation on the site one part at a time and then complete the TODOs in the associated exercise. The code can be run via the Makefile for simplicity.","title":"Workshop Structure"},{"location":"01fmt/","text":"Covered in this module: main import fmt library types variables constants hello world Entry point to your application is a main function: package main import \"fmt\" func main () { fmt . Println ( \"hello world\" ) } Files in the same package share scope import is the keyword for importing packages native packages have no path (no slashes) parenthesis can be used to import multiple packages without repeating import package main import ( \"fmt\" \"math\" ) fmt Library fmt , pronounced fumpt , provides many common utilities: printing to console parameterized strings error message creation Common fmt pattern function behavior Println print all provided parameters, newline is automatic Printf first parameter is a format string with placeholders followed by parameters to replace the placeholders. No auto newline Print print all provided parameters Common fmt format placeholders (verbs) function behavior %v default format (uses the default for types as below) %d for int, base 10 value %s uninterpreted bytes of string %t for bool, the word true or false fmt.Sprintf Returns a string built from the formatting string (first parameter) and a list of operands to replace verbs (e.g. %v ). fmt . Sprintf ( \"They're waiting for you %v\u2026 in the test chamber.\" , \"Gordon\" ) Common Primitives int string bool byte (alias for uint8) rune (alias for int32, represents a Unicode code point) float32/float64 Variables Keyword var can be used to declare one or many variables var name string You can initialize the variable inline. Types are inferred. var name = \"Gophee\" Go provides the shorthand operator := to declare and initialize a variable time := \"a flat circle\" Declaring variables that are not initialized are automatically zero-valued var ( name string num int state bool ) fmt . Printf ( \"\\\"%v\\\" - %v: %v\" , name , num , state ) prints \"\" - 0: false Note Primitives can not be nil , only pointers (pointers are covered in part 8). Constants can be a character, string, boolean, or numeric numeric constants have no inherent type can be explicitly cast when used const a = 9000 fmt . Println ( float64 ( a )) will take a type implicitly when used as a parameter const ( a = 9000 b = 4000 ) fmt . Println ( math . Max ( a , b )) // math.Max expects two float64 parameters Hands on! In the repo, open the file ./basics/01fmt.go Complete the TODOs Run make 01 from project root (alternatively, type go run ./01fmt.go ) Example implementation available on solutions branch","title":"01 - fmt-y Dumpty"},{"location":"01fmt/#hello-world","text":"Entry point to your application is a main function: package main import \"fmt\" func main () { fmt . Println ( \"hello world\" ) } Files in the same package share scope import is the keyword for importing packages native packages have no path (no slashes) parenthesis can be used to import multiple packages without repeating import package main import ( \"fmt\" \"math\" )","title":"hello world"},{"location":"01fmt/#fmt","text":"Library fmt , pronounced fumpt , provides many common utilities: printing to console parameterized strings error message creation","title":"fmt"},{"location":"01fmt/#common-fmt-pattern","text":"function behavior Println print all provided parameters, newline is automatic Printf first parameter is a format string with placeholders followed by parameters to replace the placeholders. No auto newline Print print all provided parameters","title":"Common fmt pattern"},{"location":"01fmt/#common-fmt-format-placeholders-verbs","text":"function behavior %v default format (uses the default for types as below) %d for int, base 10 value %s uninterpreted bytes of string %t for bool, the word true or false","title":"Common fmt format placeholders (verbs)"},{"location":"01fmt/#fmtsprintf","text":"Returns a string built from the formatting string (first parameter) and a list of operands to replace verbs (e.g. %v ). fmt . Sprintf ( \"They're waiting for you %v\u2026 in the test chamber.\" , \"Gordon\" )","title":"fmt.Sprintf"},{"location":"01fmt/#common-primitives","text":"int string bool byte (alias for uint8) rune (alias for int32, represents a Unicode code point) float32/float64","title":"Common Primitives"},{"location":"01fmt/#variables","text":"Keyword var can be used to declare one or many variables var name string You can initialize the variable inline. Types are inferred. var name = \"Gophee\" Go provides the shorthand operator := to declare and initialize a variable time := \"a flat circle\" Declaring variables that are not initialized are automatically zero-valued var ( name string num int state bool ) fmt . Printf ( \"\\\"%v\\\" - %v: %v\" , name , num , state ) prints \"\" - 0: false Note Primitives can not be nil , only pointers (pointers are covered in part 8).","title":"Variables"},{"location":"01fmt/#constants","text":"can be a character, string, boolean, or numeric numeric constants have no inherent type can be explicitly cast when used const a = 9000 fmt . Println ( float64 ( a )) will take a type implicitly when used as a parameter const ( a = 9000 b = 4000 ) fmt . Println ( math . Max ( a , b )) // math.Max expects two float64 parameters","title":"Constants"},{"location":"01fmt/#hands-on","text":"In the repo, open the file ./basics/01fmt.go Complete the TODOs Run make 01 from project root (alternatively, type go run ./01fmt.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"02conditionals/","text":"Covered in this module: if/else switch if/else These have a very simple structure in Go. parentheses are omitted curly braces are required related if/else clauses continue on the same line as the last closing brace i := 5 if i < 0 { fmt . Println ( \"i is negative\" ) } else if i > 0 { fmt . Println ( \"i is positive\" ) } else { fmt . Println ( \"i is 0\" ) } Note Go does not have an analog for the ternary operator! A statement can precede the condition of an if clause. Variables declared in-line are only available within the if/else block if i := 5 ; i < 0 { fmt . Println ( \"i is negative\" ) } else if i > 0 { fmt . Println ( \"i is positive\" ) } else { fmt . Println ( \"i is 0\" ) } // referencing `i` here would fail (this would be caught at compilation) switch Switch can be used as an alternative to an if/else : i := 5 switch { case i < 0 : fmt . Println ( \"i is negative\" ) case i > 0 : fmt . Println ( \"i is positive\" ) default : fmt . Println ( \"i is 0\" ) } Switch can be used for pattern matching. Cases that use the same result can be comma separated. Cases without a result are explicitly skipped. i := \"Monday\" switch i { case \"Monday\" : fmt . Println ( \"Wake up, it\u2019s a beautiful Monday\" ) case \"Tuesday\" : fmt . Println ( \"Hey everybody it\u2019s Tuesday!\" ) case \"Wednesday\" , \"Thursday\" : // these two cases get the same result fmt . Println ( \"Almost Friday\" ) case \"Friday\" : // skipped default : fmt . Printf ( \"%v is not the best day\\n\" , i ) } Default is not required but is recommended in cases where your pattern match is not exhaustive. If the switch matches no cases the code will move forward. Switch can be used to check the type of an interface (interfaces are covered in part 10): var i interface {} switch i .( type ) { case string : fmt . Println ( \"i is a string\" ) case bool : fmt . Println ( \"i is a boolean\" ) case int : fmt . Println ( \"i is an int\" ) default : fmt . Println ( \"unexpected type\" ) } Hands on! In the repo, open the file ./basics/02conditionals.go Complete the TODOs Run make 02 from project root (alternatively, type go run ./02conditionals.go ) Example implementation available on solutions branch","title":"02 - On one conditional"},{"location":"02conditionals/#ifelse","text":"These have a very simple structure in Go. parentheses are omitted curly braces are required related if/else clauses continue on the same line as the last closing brace i := 5 if i < 0 { fmt . Println ( \"i is negative\" ) } else if i > 0 { fmt . Println ( \"i is positive\" ) } else { fmt . Println ( \"i is 0\" ) } Note Go does not have an analog for the ternary operator! A statement can precede the condition of an if clause. Variables declared in-line are only available within the if/else block if i := 5 ; i < 0 { fmt . Println ( \"i is negative\" ) } else if i > 0 { fmt . Println ( \"i is positive\" ) } else { fmt . Println ( \"i is 0\" ) } // referencing `i` here would fail (this would be caught at compilation)","title":"if/else"},{"location":"02conditionals/#switch","text":"Switch can be used as an alternative to an if/else : i := 5 switch { case i < 0 : fmt . Println ( \"i is negative\" ) case i > 0 : fmt . Println ( \"i is positive\" ) default : fmt . Println ( \"i is 0\" ) } Switch can be used for pattern matching. Cases that use the same result can be comma separated. Cases without a result are explicitly skipped. i := \"Monday\" switch i { case \"Monday\" : fmt . Println ( \"Wake up, it\u2019s a beautiful Monday\" ) case \"Tuesday\" : fmt . Println ( \"Hey everybody it\u2019s Tuesday!\" ) case \"Wednesday\" , \"Thursday\" : // these two cases get the same result fmt . Println ( \"Almost Friday\" ) case \"Friday\" : // skipped default : fmt . Printf ( \"%v is not the best day\\n\" , i ) } Default is not required but is recommended in cases where your pattern match is not exhaustive. If the switch matches no cases the code will move forward. Switch can be used to check the type of an interface (interfaces are covered in part 10): var i interface {} switch i .( type ) { case string : fmt . Println ( \"i is a string\" ) case bool : fmt . Println ( \"i is a boolean\" ) case int : fmt . Println ( \"i is an int\" ) default : fmt . Println ( \"unexpected type\" ) }","title":"switch"},{"location":"02conditionals/#hands-on","text":"In the repo, open the file ./basics/02conditionals.go Complete the TODOs Run make 02 from project root (alternatively, type go run ./02conditionals.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"03slices/","text":"Covered in this module: arrays slices make append maps delete arrays Arrays in Go are an ordered list of elements with a fixed length: var numbers [ 6 ] int numbers [ 1 ] = 800 fmt . Println ( numbers [ 1 ]) Arrays are initialized as zero-valued. The above prints: [0 800 0 0 0 0] len() returns the length of array: var numbers [ 6 ] int numbers [ 1 ] = 800 fmt . Println ( len ( numbers )) prints 6 Arrays can be initialized in-line numbers := [ 6 ] int { 4 , 8 , 15 , 16 , 23 , 42 } However, arrays are typically not used in Go, at least not directly... slices On the surface, slices look just like arrays except they are missing a length declaration. numbers := [] int { 4 , 8 , 15 , 16 , 23 , 42 } numbers [ 1 ] = 800 fmt . Println ( numbers ) fmt . Println ( len ( numbers )) prints [4 800 15 16 23 42] 6 Slices are a reference to all or part of an underlying array, hence the name. make The built-in function make(type, length) can be used to initialize a slice. The length parameter is required: numbers := make ([] int , 3 ) numbers [ 1 ] = 2 numbers [ 2 ] = 3 fmt . Println ( numbers ) prints [0 2 3] If you don't know how large your slice will become, you can make a slice with an initial length of 0. append Unlike arrays, slices can change size after initialization. You can append elements to the end of a slice. numbers := make ([] int , 3 ) numbers [ 1 ] = 2 numbers [ 2 ] = 3 fmt . Println ( numbers ) // prints [0 2 3] fmt . Println ( len ( numbers )) // prints 3 numbers = append ( numbers , 5 , 8 ) fmt . Println ( numbers ) // prints [0 2 3 5 8] fmt . Println ( len ( numbers )) // prints 5 advanced note if the existing underlying array is not large enough to accept the appended values, Go will create a new larger array and re-point the slice. Append is safe to use but there is a performance cost. slice a slice You can re-slice a slice using the syntax slice[begin:end] Begin and end are optional. If either is excluded the slice boundary is used instead The value at index end is excluded days := [] string { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" } fmt . Println ( days [: 2 ], \"happy days\" ) fmt . Println ( days [ 2 : 4 ], \"happy days\" ) fmt . Println ( days [ 4 :], \"happy days\" ) fmt . Println ( \"the weekend comes\" ) fmt . Println ( \"my cycle hums\" ) fmt . Println ( \"ready to race to you\" ) prints [Sunday Monday] happy days [Tuesday Wednesday] happy days [Thursday Friday] happy days the weekend comes my cycle hums ready to race to you maps Maps are structures of unordered key-value pairs. They are declared with the syntax map[key-type]value-type . make for maps doesn't need a length parameter bases := make ( map [ string ] string ) bases [ \"G\" ] = \"Guanine\" bases [ \"T\" ] = \"Thymine\" bases [ \"A\" ] = \"Adenine\" bases [ \"C\" ] = \"Cytosine\" fmt . Println ( bases ) bases := map [ string ] string { \"G\" : \"Guanine\" , \"T\" : \"Thymine\" , \"A\" : \"Adenine\" , \"C\" : \"Cytosine\" , } fmt . Println ( bases ) When invoking make on a map, the optional second parameter is a capacity hint. bases := make ( map [ string ] string , 4 ) // capacity hint set at 4 bases [ \"G\" ] = \"Guanine\" bases [ \"T\" ] = \"Thymine\" bases [ \"A\" ] = \"Adenine\" bases [ \"C\" ] = \"Cytosine\" fmt . Println ( bases ) advanced note You can use the capacity hint to avoid extra memory allocations on the heap if you have a good idea what capacity the map will need during its lifetime. If it's possible for your key to not exist in the map, you can verify that the key exists by checking the bool returned as the second value when accessing the map by key: bases := map [ string ] string { \"G\" : \"Guanine\" , \"T\" : \"Thymine\" , \"A\" : \"Adenine\" , \"C\" : \"Cytosine\" , } maybeBase , exists := bases [ \"U\" ] fmt . Println ( exists ) // prints false fmt . Println ( maybeBase ) // prints \"\" (zero-valued string since key didn't exist) You can use this to gracefully react to scenarios where a key doesn't exist in the map. delete Values can be deleted from maps by their key with delete(mapName, key) . bases := map [ string ] string { \"G\" : \"Guanine\" , \"T\" : \"Thymine\" , \"A\" : \"Adenine\" , \"C\" : \"Cytosine\" , } delete ( bases , \"G\" ) fmt . Println ( bases ) prints map[T:Thymine A:Adenine C:Cytosine] Hands on! In the repo, open the file ./basics/03slices.go Complete the TODOs Run make 03 from project root (alternatively, type go run ./03slices.go ) Example implementation available on solutions branch","title":"03 - A healthy slice of arrays"},{"location":"03slices/#arrays","text":"Arrays in Go are an ordered list of elements with a fixed length: var numbers [ 6 ] int numbers [ 1 ] = 800 fmt . Println ( numbers [ 1 ]) Arrays are initialized as zero-valued. The above prints: [0 800 0 0 0 0] len() returns the length of array: var numbers [ 6 ] int numbers [ 1 ] = 800 fmt . Println ( len ( numbers )) prints 6 Arrays can be initialized in-line numbers := [ 6 ] int { 4 , 8 , 15 , 16 , 23 , 42 } However, arrays are typically not used in Go, at least not directly...","title":"arrays"},{"location":"03slices/#slices","text":"On the surface, slices look just like arrays except they are missing a length declaration. numbers := [] int { 4 , 8 , 15 , 16 , 23 , 42 } numbers [ 1 ] = 800 fmt . Println ( numbers ) fmt . Println ( len ( numbers )) prints [4 800 15 16 23 42] 6 Slices are a reference to all or part of an underlying array, hence the name.","title":"slices"},{"location":"03slices/#make","text":"The built-in function make(type, length) can be used to initialize a slice. The length parameter is required: numbers := make ([] int , 3 ) numbers [ 1 ] = 2 numbers [ 2 ] = 3 fmt . Println ( numbers ) prints [0 2 3] If you don't know how large your slice will become, you can make a slice with an initial length of 0.","title":"make"},{"location":"03slices/#append","text":"Unlike arrays, slices can change size after initialization. You can append elements to the end of a slice. numbers := make ([] int , 3 ) numbers [ 1 ] = 2 numbers [ 2 ] = 3 fmt . Println ( numbers ) // prints [0 2 3] fmt . Println ( len ( numbers )) // prints 3 numbers = append ( numbers , 5 , 8 ) fmt . Println ( numbers ) // prints [0 2 3 5 8] fmt . Println ( len ( numbers )) // prints 5 advanced note if the existing underlying array is not large enough to accept the appended values, Go will create a new larger array and re-point the slice. Append is safe to use but there is a performance cost.","title":"append"},{"location":"03slices/#slice-a-slice","text":"You can re-slice a slice using the syntax slice[begin:end] Begin and end are optional. If either is excluded the slice boundary is used instead The value at index end is excluded days := [] string { \"Sunday\" , \"Monday\" , \"Tuesday\" , \"Wednesday\" , \"Thursday\" , \"Friday\" } fmt . Println ( days [: 2 ], \"happy days\" ) fmt . Println ( days [ 2 : 4 ], \"happy days\" ) fmt . Println ( days [ 4 :], \"happy days\" ) fmt . Println ( \"the weekend comes\" ) fmt . Println ( \"my cycle hums\" ) fmt . Println ( \"ready to race to you\" ) prints [Sunday Monday] happy days [Tuesday Wednesday] happy days [Thursday Friday] happy days the weekend comes my cycle hums ready to race to you","title":"slice a slice"},{"location":"03slices/#maps","text":"Maps are structures of unordered key-value pairs. They are declared with the syntax map[key-type]value-type . make for maps doesn't need a length parameter bases := make ( map [ string ] string ) bases [ \"G\" ] = \"Guanine\" bases [ \"T\" ] = \"Thymine\" bases [ \"A\" ] = \"Adenine\" bases [ \"C\" ] = \"Cytosine\" fmt . Println ( bases ) bases := map [ string ] string { \"G\" : \"Guanine\" , \"T\" : \"Thymine\" , \"A\" : \"Adenine\" , \"C\" : \"Cytosine\" , } fmt . Println ( bases ) When invoking make on a map, the optional second parameter is a capacity hint. bases := make ( map [ string ] string , 4 ) // capacity hint set at 4 bases [ \"G\" ] = \"Guanine\" bases [ \"T\" ] = \"Thymine\" bases [ \"A\" ] = \"Adenine\" bases [ \"C\" ] = \"Cytosine\" fmt . Println ( bases ) advanced note You can use the capacity hint to avoid extra memory allocations on the heap if you have a good idea what capacity the map will need during its lifetime. If it's possible for your key to not exist in the map, you can verify that the key exists by checking the bool returned as the second value when accessing the map by key: bases := map [ string ] string { \"G\" : \"Guanine\" , \"T\" : \"Thymine\" , \"A\" : \"Adenine\" , \"C\" : \"Cytosine\" , } maybeBase , exists := bases [ \"U\" ] fmt . Println ( exists ) // prints false fmt . Println ( maybeBase ) // prints \"\" (zero-valued string since key didn't exist) You can use this to gracefully react to scenarios where a key doesn't exist in the map.","title":"maps"},{"location":"03slices/#delete","text":"Values can be deleted from maps by their key with delete(mapName, key) . bases := map [ string ] string { \"G\" : \"Guanine\" , \"T\" : \"Thymine\" , \"A\" : \"Adenine\" , \"C\" : \"Cytosine\" , } delete ( bases , \"G\" ) fmt . Println ( bases ) prints map[T:Thymine A:Adenine C:Cytosine]","title":"delete"},{"location":"03slices/#hands-on","text":"In the repo, open the file ./basics/03slices.go Complete the TODOs Run make 03 from project root (alternatively, type go run ./03slices.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"04loops/","text":"Covered in this module: for range loops Go only has a single loop construct - for . The Go compiler does allow forever loops: for {} for A condition can be provided to make the loop behave like a while loop you would see in other languages: i := 0 for i < 10 { fmt . Println ( i ) i ++ } You can also provide before, condition, and after clauses separated by semicolons. for i := 0 ; i < 10 ; i ++ { fmt . Println ( i ) } factors := [] int { 10 , 20 , 30 , 40 , 50 } product := 1 for i := 0 ; i < len ( factors ); i ++ { product *= factors [ i ] } fmt . Println ( \"Product is\" , product ) If you use the before/condition/after loop the semicolons are required but it is not required to have something in all three sub-clauses. \"Wait\" , you say, \"there has to be a more concise way to loop over a slice, right?\" range Yep factors := [] int { 10 , 20 , 30 , 40 , 50 } product := 1 for _ , factor := range factors { product *= factor } fmt . Println ( \"Product is\" , product ) Range returns two parameters for iterable types: the index, and the value. The for loop will automatically loop over all elements of the provided iterable: factors := [] int { 10 , 20 , 30 , 40 , 50 } product := 1 for ind , factor := range factors { fmt . Println ( \"I factored index\" , ind ) product *= factor } fmt . Println ( \"Product is\" , product ) prints I factored index 0 I factored index 1 I factored index 2 I factored index 3 I factored index 4 Product is 12000000 As you can see, using range with a slice yields index and value. It does the same with a string, but the values aren\u2019t characters. They are runes which is an alias for the int32 type, each representing a unicode code point: str := \"my cool string\" for ind , r := range str { fmt . Printf ( \"Index %v is the rune %v\\n\" , ind , r ) } prints Index 0 is the rune 109 Index 1 is the rune 121 Index 2 is the rune 32 Index 3 is the rune 99 Index 4 is the rune 111 Index 5 is the rune 111 Index 6 is the rune 108 Index 7 is the rune 32 Index 8 is the rune 115 Index 9 is the rune 116 Index 10 is the rune 114 Index 11 is the rune 105 Index 12 is the rune 110 Index 13 is the rune 103 You can use string(<rune value>) to cast a rune to a string or use the fmt verb %c in your format string advanced note The Go blog has a great post that explains the differences between strings, bytes, runes, and characters in Go You can also range over maps. For maps, range yields the keys and values: m := map [ string ] string { \"A\" : \"Alfa\" , \"B\" : \"Bravo\" , \"C\" : \"Charlie\" } for key , value := range m { fmt . Printf ( \"Key %v holds value %v\\n\" , key , value ) } prints Key C holds value Charlie Key A holds value Alfa Key B holds value Bravo If you don\u2019t need the key/index, you can throw it out by replacing with underscore _ . If you don\u2019t need the value, you can omit it and the comma-space. Its important to remember that maps are unordered, so if you are transforming a map to a slice or printing from a map the keys will be returned in an unpredictable order! Hands on! In the repo, open the file ./basics/04loops.go Complete the TODOs Run make 04 from project root (alternatively, type go run ./04loops.go ) Example implementation available on solutions branch","title":"04 - Stuck in the loop with you"},{"location":"04loops/#loops","text":"Go only has a single loop construct - for . The Go compiler does allow forever loops: for {}","title":"loops"},{"location":"04loops/#for","text":"A condition can be provided to make the loop behave like a while loop you would see in other languages: i := 0 for i < 10 { fmt . Println ( i ) i ++ } You can also provide before, condition, and after clauses separated by semicolons. for i := 0 ; i < 10 ; i ++ { fmt . Println ( i ) } factors := [] int { 10 , 20 , 30 , 40 , 50 } product := 1 for i := 0 ; i < len ( factors ); i ++ { product *= factors [ i ] } fmt . Println ( \"Product is\" , product ) If you use the before/condition/after loop the semicolons are required but it is not required to have something in all three sub-clauses. \"Wait\" , you say, \"there has to be a more concise way to loop over a slice, right?\"","title":"for"},{"location":"04loops/#range","text":"Yep factors := [] int { 10 , 20 , 30 , 40 , 50 } product := 1 for _ , factor := range factors { product *= factor } fmt . Println ( \"Product is\" , product ) Range returns two parameters for iterable types: the index, and the value. The for loop will automatically loop over all elements of the provided iterable: factors := [] int { 10 , 20 , 30 , 40 , 50 } product := 1 for ind , factor := range factors { fmt . Println ( \"I factored index\" , ind ) product *= factor } fmt . Println ( \"Product is\" , product ) prints I factored index 0 I factored index 1 I factored index 2 I factored index 3 I factored index 4 Product is 12000000 As you can see, using range with a slice yields index and value. It does the same with a string, but the values aren\u2019t characters. They are runes which is an alias for the int32 type, each representing a unicode code point: str := \"my cool string\" for ind , r := range str { fmt . Printf ( \"Index %v is the rune %v\\n\" , ind , r ) } prints Index 0 is the rune 109 Index 1 is the rune 121 Index 2 is the rune 32 Index 3 is the rune 99 Index 4 is the rune 111 Index 5 is the rune 111 Index 6 is the rune 108 Index 7 is the rune 32 Index 8 is the rune 115 Index 9 is the rune 116 Index 10 is the rune 114 Index 11 is the rune 105 Index 12 is the rune 110 Index 13 is the rune 103 You can use string(<rune value>) to cast a rune to a string or use the fmt verb %c in your format string advanced note The Go blog has a great post that explains the differences between strings, bytes, runes, and characters in Go You can also range over maps. For maps, range yields the keys and values: m := map [ string ] string { \"A\" : \"Alfa\" , \"B\" : \"Bravo\" , \"C\" : \"Charlie\" } for key , value := range m { fmt . Printf ( \"Key %v holds value %v\\n\" , key , value ) } prints Key C holds value Charlie Key A holds value Alfa Key B holds value Bravo If you don\u2019t need the key/index, you can throw it out by replacing with underscore _ . If you don\u2019t need the value, you can omit it and the comma-space. Its important to remember that maps are unordered, so if you are transforming a map to a slice or printing from a map the keys will be returned in an unpredictable order!","title":"range"},{"location":"04loops/#hands-on","text":"In the repo, open the file ./basics/04loops.go Complete the TODOs Run make 04 from project root (alternatively, type go run ./04loops.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"05functions/","text":"Covered in this module: functions variadic functions functions We've been using functions for almost the whole workshop so far, but let's look take a closer look. Go Functions require an explicit parameter list and return type. The function name comes immediately after the func keyword and then a comma-space separated list of parameters wrapped in parentheses. Each parameter has a name and then a type separated by a space. The return type is specified after the parameter list followed by an enclosure {} . You must also explicitly return from your function if it has a return type. The returned value must be the same type as the declared return type. func max ( a int , b int ) int { if a >= b { return a } return b } Functions without a return type do not need a return and will run through all statements: func print ( message string ) { fmt . Println ( message ) } You invoke a function with the parameters wrapped in parentheses: package main import \"fmt\" func main () { prnt ( \"something important\" ) } func prnt ( message string ) { fmt . Println ( message ) } Functions can have multiple returned values, comma separated and wrapped in parentheses. Return types are still enforced and return must have the same number of values: func negativePositive ( i float64 ) ( float64 , float64 ) { return - math . Abs ( i ), math . Abs ( i ) } return immediately stops the function. This function will return goodbye and never print \"unreachable code\" . func signOff () string { return \"goodbye\" fmt . Println ( \"unreachable code\" ) return \"farewell\" } named return values Return values can be named. The values are initialized as zero-valued when the function is invoked. A naked return will return the named return values in their current state: func concat ( strs ... string ) ( output string ) { for _ , str := range strs { output += str } return } The named returned values can be overridden by explicitly returning values of the correct type: func concat ( strs ... string ) ( output string ) { for _ , str := range strs { output += str } if len ( output ) >= 21 { return } return \"real output too short\" } variadic functions The last parameter of a function can take any number of arguments of the same type: func concat ( strs ... string ) string { var output string for _ , str := range strs { output += str } return output } capture returned values When calling a function, you capture the returned values into variables: package main import \"fmt\" func main () { strings1 := [] string { \"A\" , \"E\" , \"I\" , \"O\" , \"U\" , \"sometimes\" , \"Y\" } strings2 := [] string { \"E\" , \"B\" , \"N\" , \"/\" , \"O\" , \"Z\" , \"N\" } title := concat ( strings1 ... ) var artist string artist = concat ( strings2 ... ) fmt . Println ( title , artist ) } func concat ( strs ... string ) ( output string ) { for _ , str := range strs { output += str } return } All values returned from a function must be captured or explicitly ignored using _ func main () { first , second := someStrings () third , _ := someStrings () fourth := someStrings () // compiler throws error here } func someStrings () ( string , string ) { // snippet } Functions can return many values as a tuple, but you sacrifice readability especially in a case where the returned values are not named: func main () { year , _ , day , hour , min , _ := getDate () fmt . Println ( year , day , hour , min ) } func getDate () ( int , int , int , int , int , int ) { // snippet return year , month , day , hour , min , sec } Note There may be some instances where it is warranted, but a good rule of thumb is try to avoid return value lists over three values. Part 9 will introduce the struct type for collecting data into logical groupings. Hands on! In the repo, open the file ./basics/05functions.go Complete the TODOs Run make 05 from project root (alternatively, type go run ./05functions.go ) Example implementation available on solutions branch","title":"05 - Becoming a functioning Gopher"},{"location":"05functions/#functions","text":"We've been using functions for almost the whole workshop so far, but let's look take a closer look. Go Functions require an explicit parameter list and return type. The function name comes immediately after the func keyword and then a comma-space separated list of parameters wrapped in parentheses. Each parameter has a name and then a type separated by a space. The return type is specified after the parameter list followed by an enclosure {} . You must also explicitly return from your function if it has a return type. The returned value must be the same type as the declared return type. func max ( a int , b int ) int { if a >= b { return a } return b } Functions without a return type do not need a return and will run through all statements: func print ( message string ) { fmt . Println ( message ) } You invoke a function with the parameters wrapped in parentheses: package main import \"fmt\" func main () { prnt ( \"something important\" ) } func prnt ( message string ) { fmt . Println ( message ) } Functions can have multiple returned values, comma separated and wrapped in parentheses. Return types are still enforced and return must have the same number of values: func negativePositive ( i float64 ) ( float64 , float64 ) { return - math . Abs ( i ), math . Abs ( i ) } return immediately stops the function. This function will return goodbye and never print \"unreachable code\" . func signOff () string { return \"goodbye\" fmt . Println ( \"unreachable code\" ) return \"farewell\" }","title":"functions"},{"location":"05functions/#named-return-values","text":"Return values can be named. The values are initialized as zero-valued when the function is invoked. A naked return will return the named return values in their current state: func concat ( strs ... string ) ( output string ) { for _ , str := range strs { output += str } return } The named returned values can be overridden by explicitly returning values of the correct type: func concat ( strs ... string ) ( output string ) { for _ , str := range strs { output += str } if len ( output ) >= 21 { return } return \"real output too short\" }","title":"named return values"},{"location":"05functions/#variadic-functions","text":"The last parameter of a function can take any number of arguments of the same type: func concat ( strs ... string ) string { var output string for _ , str := range strs { output += str } return output }","title":"variadic functions"},{"location":"05functions/#capture-returned-values","text":"When calling a function, you capture the returned values into variables: package main import \"fmt\" func main () { strings1 := [] string { \"A\" , \"E\" , \"I\" , \"O\" , \"U\" , \"sometimes\" , \"Y\" } strings2 := [] string { \"E\" , \"B\" , \"N\" , \"/\" , \"O\" , \"Z\" , \"N\" } title := concat ( strings1 ... ) var artist string artist = concat ( strings2 ... ) fmt . Println ( title , artist ) } func concat ( strs ... string ) ( output string ) { for _ , str := range strs { output += str } return } All values returned from a function must be captured or explicitly ignored using _ func main () { first , second := someStrings () third , _ := someStrings () fourth := someStrings () // compiler throws error here } func someStrings () ( string , string ) { // snippet } Functions can return many values as a tuple, but you sacrifice readability especially in a case where the returned values are not named: func main () { year , _ , day , hour , min , _ := getDate () fmt . Println ( year , day , hour , min ) } func getDate () ( int , int , int , int , int , int ) { // snippet return year , month , day , hour , min , sec } Note There may be some instances where it is warranted, but a good rule of thumb is try to avoid return value lists over three values. Part 9 will introduce the struct type for collecting data into logical groupings.","title":"capture returned values"},{"location":"05functions/#hands-on","text":"In the repo, open the file ./basics/05functions.go Complete the TODOs Run make 05 from project root (alternatively, type go run ./05functions.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"06errors/","text":"Covered in this module: errors error syntax errors Go provides a built-in interface called error that has a single method Error() that returns the error message string. (interfaces will be covered later). Errors can be created with errors.New() : err := errors . New ( \"I am Error\" ) fmt . Printf ( \"%v - Press any key to restart\" , err . Error ()) prints I am Error - Press any key to restart fmt.Errorf() can be used to create error text at runtime (as opposed to errors.New(fmt.Sprintf()) : number := - 10 var err error if number < 0 { err = fmt . Errorf ( \"%v is not positive\" , number ) } error syntax By convention, any function that can return an error has error as its last return value. nil can be returned in place of an error: func bePositive ( number int ) ( string , error ) { if number < 0 { return \"\" , fmt . Errorf ( \"%v is not positive\" , number ) } return \"I'm so happy\" , nil } A common structure that arises in Go code is: Invoke a function that can return an error React to error if its not nil Continue normal operation number := - 10 tidbit , err := bePositive ( number ) if err != nil { fmt . Println ( \"Error encountered:\" , err . Error ()) } fmt . Println ( tidbit ) error wrapping fmt.Errorf has a special verb %w (since 1.13) that enables generation of a stack-trace-like structure and saves manually calling err.Error() to properly print error strings. %w is only available for fmt.Errorf() . func getDescription ( id int ) ( string , error ) { if desc , err := getDescriptionByID ( id ); err != nil { return \"\" , fmt . Errorf ( \"getDescriptionByID: %w\" , err ) } else { return desc , nil } } Printing the returned error gives: getDescriptionByID: id doesn't exist in database A common pattern is to indicate which function was invoked that yielded the error, so that you can pinpoint the issue from the logged errors. By convention, errors shouldn't begin with a capital letter or end in punctuation. Steps in the 'stack-trace' are indicated by : If a function only returns an error , the compiler does allow you to skip capturing the returned value, but by convention you should explicitly ignore it with _ . func main () { mightErrDontCare () // allowed by the compiler _ = mightErrDontCare () // functionally the same, but increases readability } func mightErrDontCare () error { // snippet } errors as a construct Errors don\u2019t have any special behavior: they are just like any other return value It\u2019s up to the function caller to handle them how they like Go does have an exception state called panic that will be covered in the next section. Hands on! In the repo, open the file ./basics/06errors.go Complete the TODOs Run make 06 from project root (alternatively, type go run ./06errors.go ) Example implementation available on solutions branch","title":"06 - I am Error"},{"location":"06errors/#errors","text":"Go provides a built-in interface called error that has a single method Error() that returns the error message string. (interfaces will be covered later). Errors can be created with errors.New() : err := errors . New ( \"I am Error\" ) fmt . Printf ( \"%v - Press any key to restart\" , err . Error ()) prints I am Error - Press any key to restart fmt.Errorf() can be used to create error text at runtime (as opposed to errors.New(fmt.Sprintf()) : number := - 10 var err error if number < 0 { err = fmt . Errorf ( \"%v is not positive\" , number ) }","title":"errors"},{"location":"06errors/#error-syntax","text":"By convention, any function that can return an error has error as its last return value. nil can be returned in place of an error: func bePositive ( number int ) ( string , error ) { if number < 0 { return \"\" , fmt . Errorf ( \"%v is not positive\" , number ) } return \"I'm so happy\" , nil } A common structure that arises in Go code is: Invoke a function that can return an error React to error if its not nil Continue normal operation number := - 10 tidbit , err := bePositive ( number ) if err != nil { fmt . Println ( \"Error encountered:\" , err . Error ()) } fmt . Println ( tidbit )","title":"error syntax"},{"location":"06errors/#error-wrapping","text":"fmt.Errorf has a special verb %w (since 1.13) that enables generation of a stack-trace-like structure and saves manually calling err.Error() to properly print error strings. %w is only available for fmt.Errorf() . func getDescription ( id int ) ( string , error ) { if desc , err := getDescriptionByID ( id ); err != nil { return \"\" , fmt . Errorf ( \"getDescriptionByID: %w\" , err ) } else { return desc , nil } } Printing the returned error gives: getDescriptionByID: id doesn't exist in database A common pattern is to indicate which function was invoked that yielded the error, so that you can pinpoint the issue from the logged errors. By convention, errors shouldn't begin with a capital letter or end in punctuation. Steps in the 'stack-trace' are indicated by : If a function only returns an error , the compiler does allow you to skip capturing the returned value, but by convention you should explicitly ignore it with _ . func main () { mightErrDontCare () // allowed by the compiler _ = mightErrDontCare () // functionally the same, but increases readability } func mightErrDontCare () error { // snippet }","title":"error wrapping"},{"location":"06errors/#errors-as-a-construct","text":"Errors don\u2019t have any special behavior: they are just like any other return value It\u2019s up to the function caller to handle them how they like Go does have an exception state called panic that will be covered in the next section.","title":"errors as a construct"},{"location":"06errors/#hands-on","text":"In the repo, open the file ./basics/06errors.go Complete the TODOs Run make 06 from project root (alternatively, type go run ./06errors.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"07panics/","text":"Covered in this module: defer panic recover defer Any function passed to defer will be run after the containing function completes: package main import \"fmt\" func main () { defer fmt . Println ( \"Clubs\" ) defer fmt . Println ( \"Diamonds\" ) fmt . Println ( \"Hearts\" ) fmt . Println ( \"Spades\" ) } prints Hearts Spades Diamonds Clubs Defers are invoked in reverse order (LIFO, last in first out). One common use-case is to defer teardown of resources so they are cleaned up early rather than having to wait on the garbage collector or for cases where the GC may not properly clean up a resource: db , err := sql . Open ( \"postgres\" , connectionString ) if err != nil { return fmt . Errorf ( \"sql.Open: %w\" , err ) } defer func () { _ = db . Close () }() rows , err := db . Query ( \"select * from users\" ) if err != nil { return fmt . Errorf ( \"db.Query: %w\" , err ) } defer func () { _ = rows . Close () }() Note We don't defer close on the db or rows until after the error check. There is no need to close a resource that didn't get initialized (indicated by the not-nil error). The LIFO behavior of defers here makes it so rows is closed first and then db . You wouldn't want to close the db until the rows resource is properly closed. Return values can be modified within the deferred function: func main () { _ , err := convert ( \"two\" ) fmt . Println ( err ) } func convert ( input string ) ( output int , errs error ) { defer func () { if errs != nil { errs = fmt . Errorf ( \"ya burnt! %v\" , errs . Error ()) } }() return strconv . Atoi ( input ) // attempts to convert string to int } prints ya burnt! strconv.Atoi: parsing \"two\": invalid syntax panic Unlike errors which are handled like any other type, panic triggers an exception: func main () { for { doNotPanic () } } func doNotPanic () { panic ( \"I told you not to panic\" ) } The panic function accepts a value of any type. recover Panics can be recovered by a deferred function: func main () { defer fmt . Println ( \"End of line, man...\" ) defer func () { recovered := recover () if recovered != nil { fmt . Println ( \"Recovered from panic:\" , recovered ) } }() result := mustConvert ( \"two\" ) fmt . Println ( \"Result of conversion:\" , result ) } func mustConvert ( input string ) int { output , err := strconv . Atoi ( input ) if err != nil { panic ( err ) } return output } prints Recovered from panic: strconv.Atoi: parsing \"two\": invalid syntax End of line, man... Avoid using panic in your production code except for specialized use-cases. Panics are meant for unrecoverable errors. As with exception states in other languages, if you do not recover a panic it will kill your app. One valid use-case would be on app start-up if a component fails to initialize. If you do have a function that could panic, the recommendation is to prepend the name with must (e.g. mustConvert ). That indicates to anyone who uses that function that it could panic. Panics will occur for various reasons in compiled Go code, such as trying to index a value out of bounds in a slice or if you dereference a nil pointer. Pointers are covered in the next section. Hands on! In the repo, open the file ./intermediate/07panics.go Complete the TODOs Run make 07 from project root (alternatively, type go run ./07panics.go ) Example implementation available on solutions branch","title":"07 - Don't panic"},{"location":"07panics/#defer","text":"Any function passed to defer will be run after the containing function completes: package main import \"fmt\" func main () { defer fmt . Println ( \"Clubs\" ) defer fmt . Println ( \"Diamonds\" ) fmt . Println ( \"Hearts\" ) fmt . Println ( \"Spades\" ) } prints Hearts Spades Diamonds Clubs Defers are invoked in reverse order (LIFO, last in first out). One common use-case is to defer teardown of resources so they are cleaned up early rather than having to wait on the garbage collector or for cases where the GC may not properly clean up a resource: db , err := sql . Open ( \"postgres\" , connectionString ) if err != nil { return fmt . Errorf ( \"sql.Open: %w\" , err ) } defer func () { _ = db . Close () }() rows , err := db . Query ( \"select * from users\" ) if err != nil { return fmt . Errorf ( \"db.Query: %w\" , err ) } defer func () { _ = rows . Close () }() Note We don't defer close on the db or rows until after the error check. There is no need to close a resource that didn't get initialized (indicated by the not-nil error). The LIFO behavior of defers here makes it so rows is closed first and then db . You wouldn't want to close the db until the rows resource is properly closed. Return values can be modified within the deferred function: func main () { _ , err := convert ( \"two\" ) fmt . Println ( err ) } func convert ( input string ) ( output int , errs error ) { defer func () { if errs != nil { errs = fmt . Errorf ( \"ya burnt! %v\" , errs . Error ()) } }() return strconv . Atoi ( input ) // attempts to convert string to int } prints ya burnt! strconv.Atoi: parsing \"two\": invalid syntax","title":"defer"},{"location":"07panics/#panic","text":"Unlike errors which are handled like any other type, panic triggers an exception: func main () { for { doNotPanic () } } func doNotPanic () { panic ( \"I told you not to panic\" ) } The panic function accepts a value of any type.","title":"panic"},{"location":"07panics/#recover","text":"Panics can be recovered by a deferred function: func main () { defer fmt . Println ( \"End of line, man...\" ) defer func () { recovered := recover () if recovered != nil { fmt . Println ( \"Recovered from panic:\" , recovered ) } }() result := mustConvert ( \"two\" ) fmt . Println ( \"Result of conversion:\" , result ) } func mustConvert ( input string ) int { output , err := strconv . Atoi ( input ) if err != nil { panic ( err ) } return output } prints Recovered from panic: strconv.Atoi: parsing \"two\": invalid syntax End of line, man... Avoid using panic in your production code except for specialized use-cases. Panics are meant for unrecoverable errors. As with exception states in other languages, if you do not recover a panic it will kill your app. One valid use-case would be on app start-up if a component fails to initialize. If you do have a function that could panic, the recommendation is to prepend the name with must (e.g. mustConvert ). That indicates to anyone who uses that function that it could panic. Panics will occur for various reasons in compiled Go code, such as trying to index a value out of bounds in a slice or if you dereference a nil pointer. Pointers are covered in the next section.","title":"recover"},{"location":"07panics/#hands-on","text":"In the repo, open the file ./intermediate/07panics.go Complete the TODOs Run make 07 from project root (alternatively, type go run ./07panics.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"08pointers/","text":"Covered in this module: pointers dereferencing pointers Go defaults to passing parameters by value: func main () { star := \"Sol\" fmt . Println ( star ) toUpper ( star ) fmt . Println ( star ) } func toUpper ( input string ) { input = strings . ToUpper ( input ) } prints Sol Sol You may have noticed that toUpper didn't have an effect on the output, because it modified its input parameter, which was a copy of the string passed in by main . toUpper would only be able to copy the string initialized in main if we pass by reference, via a pointer. referencing You can get the address of a value with the reference syntax: func main () { star := \"Sol\" fmt . Println ( star ) toUpper ( & star ) // pass reference to star fmt . Println ( star ) } func toUpper ( input * string ) { * input = strings . ToUpper ( * input ) // modify pointed-to value } prints Sol SOL The example above passed a reference to star , which toUpper then dereferences so it can modify the underlying string. operator term behavior & reference get the address of the given value * dereference get the value from the given address Note * is used to indicate a type as a pointer (e.g. *string ) and is also used to dereference pointers. You can get the address of a value with the reference syntax: func main () { moon := \"Luna\" fmt . Println ( moon ) fmt . Println ( & moon ) } prints Luna 0xc00000e1e0 Note Pointer types are referred to verbally by prepending pointer to the type. For example, *string is a pointer string and *int is a pointer int. nil Unlike primitives, a pointer can be nil. func main () { toUpper ( nil ) } func toUpper ( input * string ) { * input = strings . ToUpper ( * input ) } This example panics because strings.ToUpper is attempting to deference a nil pointer. It's a good practice to always check nil -able values before trying to use them (unless you know for sure that the pointer can never be nil): func main () { toUpper ( nil ) } func toUpper ( input * string ) { if input != nil { * input = strings . ToUpper ( * input ) } } Hands on! In the repo, open the file ./intermediate/08pointers.go Complete the TODOs Run make 08 from project root (alternatively, type go run ./08pointers.go ) Example implementation available on solutions branch","title":"08 - Get to the point"},{"location":"08pointers/#pointers","text":"Go defaults to passing parameters by value: func main () { star := \"Sol\" fmt . Println ( star ) toUpper ( star ) fmt . Println ( star ) } func toUpper ( input string ) { input = strings . ToUpper ( input ) } prints Sol Sol You may have noticed that toUpper didn't have an effect on the output, because it modified its input parameter, which was a copy of the string passed in by main . toUpper would only be able to copy the string initialized in main if we pass by reference, via a pointer.","title":"pointers"},{"location":"08pointers/#referencing","text":"You can get the address of a value with the reference syntax: func main () { star := \"Sol\" fmt . Println ( star ) toUpper ( & star ) // pass reference to star fmt . Println ( star ) } func toUpper ( input * string ) { * input = strings . ToUpper ( * input ) // modify pointed-to value } prints Sol SOL The example above passed a reference to star , which toUpper then dereferences so it can modify the underlying string. operator term behavior & reference get the address of the given value * dereference get the value from the given address Note * is used to indicate a type as a pointer (e.g. *string ) and is also used to dereference pointers. You can get the address of a value with the reference syntax: func main () { moon := \"Luna\" fmt . Println ( moon ) fmt . Println ( & moon ) } prints Luna 0xc00000e1e0 Note Pointer types are referred to verbally by prepending pointer to the type. For example, *string is a pointer string and *int is a pointer int.","title":"referencing"},{"location":"08pointers/#nil","text":"Unlike primitives, a pointer can be nil. func main () { toUpper ( nil ) } func toUpper ( input * string ) { * input = strings . ToUpper ( * input ) } This example panics because strings.ToUpper is attempting to deference a nil pointer. It's a good practice to always check nil -able values before trying to use them (unless you know for sure that the pointer can never be nil): func main () { toUpper ( nil ) } func toUpper ( input * string ) { if input != nil { * input = strings . ToUpper ( * input ) } }","title":"nil"},{"location":"08pointers/#hands-on","text":"In the repo, open the file ./intermediate/08pointers.go Complete the TODOs Run make 08 from project root (alternatively, type go run ./08pointers.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"09structs/","text":"Covered in this module: structs methods structs Go structs are a way of collecting related items into an object/record: type character struct { name string class string level int } func main () { char := character { name : \"Helmut Van Kaiser\" , class : \"Fighter\" , level : 4 } fmt . Println ( char ) } Struct properties are mutable and can be accessed with dot notation: char := character { name : \"Helmut Van Kaiser\" , class : \"Fighter\" , level : 4 } fmt . Println ( char . name ) fmt . Println ( char . class ) fmt . Println ( char . level ) char . level ++ fmt . Println ( char . level ) prints Helmut Van Kaiser Fighter 4 5 Struct properties are not required at initialization and are zero-valued by default: char := character { name : \"Helmut Van Kaiser\" } fmt . Println ( char . name ) fmt . Println ( char . class ) fmt . Println ( char . level ) prints Helmut Van Kaiser 0 Passing a struct as a pointer avoids making another copy: func main () { char := character { name : \"Helmut Van Kaiser\" , class : \"Fighter\" , level : 4 } fmt . Println ( char . name ) fmt . Println ( char . class ) fmt . Println ( char . level ) levelUp ( & char ) fmt . Println ( char . level ) } func levelUp ( char * character ) { char . level ++ } prints Helmut Van Kaiser Fighter 4 5 methods Structs can have methods that have access to struct properties: type character struct { name string class string level int } func ( char * character ) levelUp () { char . level ++ } func main () { char := character { name : \"Helmut Van Kaiser\" , class : \"Fighter\" , level : 4 } fmt . Println ( char . name ) fmt . Println ( char . class ) fmt . Println ( char . level ) char . levelUp () fmt . Println ( char . level ) } prints Helmut Van Kaiser Fighter 4 5 pointer vs value receiver You can pass your struct by value or by reference to your method. If your method needs to modify the struct in some way, it must be passed as a pointer. type character struct { name string class string level int } func ( char * character ) levelUp () { // pointer receiver char . level ++ } func ( char character ) card () string { // value receiver return fmt . Sprintf ( \"Player %v is a level %v %v\" , char . name , char . level , char . class ) } func main () { char := character { name : \"Helmut Van Kaiser\" , class : \"Fighter\" , level : 4 } fmt . Println ( char . card ()) char . levelUp () fmt . Println ( char . card ()) } Note By convention, receiver names should be related to the struct in some way. A receiver for character struct might be c or char but never self or this . All methods for the same struct should share the same receiver name, regardless of if they are pointer or value receivers. The compiler does not catch cases where your method modifies your struct passed by value: type character struct { name string class string level int } func ( char character ) levelUp () { // value receiver char . level ++ // level++ modifies the struct copy } func main () { char := character { name : \"Helmut Van Kaiser\" , class : \"Fighter\" , level : 4 } fmt . Println ( char . name ) fmt . Println ( char . class ) fmt . Println ( char . level ) char . levelUp () fmt . Println ( char . level ) } prints Helmut Van Kaiser Fighter 4 4 Note There are linters such as revive available to help catch cases like this, which can be tricky to notice manually. Hands on! In the repo, open the file ./intermediate/09structs.go Complete the TODOs Run make 09 from project root (alternatively, type go run ./09structs.go ) Example implementation available on solutions branch","title":"09 - Hardwired to self de-struct"},{"location":"09structs/#structs","text":"Go structs are a way of collecting related items into an object/record: type character struct { name string class string level int } func main () { char := character { name : \"Helmut Van Kaiser\" , class : \"Fighter\" , level : 4 } fmt . Println ( char ) } Struct properties are mutable and can be accessed with dot notation: char := character { name : \"Helmut Van Kaiser\" , class : \"Fighter\" , level : 4 } fmt . Println ( char . name ) fmt . Println ( char . class ) fmt . Println ( char . level ) char . level ++ fmt . Println ( char . level ) prints Helmut Van Kaiser Fighter 4 5 Struct properties are not required at initialization and are zero-valued by default: char := character { name : \"Helmut Van Kaiser\" } fmt . Println ( char . name ) fmt . Println ( char . class ) fmt . Println ( char . level ) prints Helmut Van Kaiser 0 Passing a struct as a pointer avoids making another copy: func main () { char := character { name : \"Helmut Van Kaiser\" , class : \"Fighter\" , level : 4 } fmt . Println ( char . name ) fmt . Println ( char . class ) fmt . Println ( char . level ) levelUp ( & char ) fmt . Println ( char . level ) } func levelUp ( char * character ) { char . level ++ } prints Helmut Van Kaiser Fighter 4 5","title":"structs"},{"location":"09structs/#methods","text":"Structs can have methods that have access to struct properties: type character struct { name string class string level int } func ( char * character ) levelUp () { char . level ++ } func main () { char := character { name : \"Helmut Van Kaiser\" , class : \"Fighter\" , level : 4 } fmt . Println ( char . name ) fmt . Println ( char . class ) fmt . Println ( char . level ) char . levelUp () fmt . Println ( char . level ) } prints Helmut Van Kaiser Fighter 4 5","title":"methods"},{"location":"09structs/#pointer-vs-value-receiver","text":"You can pass your struct by value or by reference to your method. If your method needs to modify the struct in some way, it must be passed as a pointer. type character struct { name string class string level int } func ( char * character ) levelUp () { // pointer receiver char . level ++ } func ( char character ) card () string { // value receiver return fmt . Sprintf ( \"Player %v is a level %v %v\" , char . name , char . level , char . class ) } func main () { char := character { name : \"Helmut Van Kaiser\" , class : \"Fighter\" , level : 4 } fmt . Println ( char . card ()) char . levelUp () fmt . Println ( char . card ()) } Note By convention, receiver names should be related to the struct in some way. A receiver for character struct might be c or char but never self or this . All methods for the same struct should share the same receiver name, regardless of if they are pointer or value receivers. The compiler does not catch cases where your method modifies your struct passed by value: type character struct { name string class string level int } func ( char character ) levelUp () { // value receiver char . level ++ // level++ modifies the struct copy } func main () { char := character { name : \"Helmut Van Kaiser\" , class : \"Fighter\" , level : 4 } fmt . Println ( char . name ) fmt . Println ( char . class ) fmt . Println ( char . level ) char . levelUp () fmt . Println ( char . level ) } prints Helmut Van Kaiser Fighter 4 4 Note There are linters such as revive available to help catch cases like this, which can be tricky to notice manually.","title":"pointer vs value receiver"},{"location":"09structs/#hands-on","text":"In the repo, open the file ./intermediate/09structs.go Complete the TODOs Run make 09 from project root (alternatively, type go run ./09structs.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"10interfaces/","text":"Covered in this module: interfaces interface An interface in Go is a collection of methods. Interface declaration is quite similar to structs except you list the methods that the interface has rather than properties. The interface method parameters and return types can be named. The names are optional but may add clarity to the interface. The following two interfaces are equivalent. type animal interface { speak () string eat ( int ) string poo ( int ) string } type animal interface { speak () ( message string ) eat ( ounces int ) ( message string ) poo ( ounces int ) ( message string ) } Any struct that implements all the methods of an interface is then considered as implementing that interface: type animal interface { speak () string eat ( int ) string poo ( int ) string } type dog struct { name string digestingFoodOunces int } func ( d dog ) speak () string { return \"rrrr RUFF!\" } func ( d * dog ) eat ( ounces int ) string { d . digestingFoodOunces += ounces return fmt . Sprintf ( \"%v ate and is now digesting %v ounces of food\" , d . name , d . digestingFoodOunces ) } func ( d * dog ) poo ( ounces int ) string { d . digestingFoodOunces -= ounces return fmt . Sprintf ( \"%v poo'd and is now digesting %v ounces of food\" , d . name , d . digestingFoodOunces ) } Using an interface as a parameter enables a function to accept any struct that implements the interface: func main () { d := dog { name : \"Ein\" } feedAnimal ( & d ) } func feedAnimal ( a animal ) { fmt . Println ( a . eat ( 10 )) fmt . Println ( a . speak ()) } Because eat() and poo() have a pointer receiver, only a pointer dog (the type, not the breed) satisfies the interface. The blackHole struct below only uses value receivers so it can be passed by value: type animal interface { speak () string eat ( int ) string poo ( int ) string } type blackHole struct { name string } func ( b blackHole ) speak () string { return \"...........\" } func ( b blackHole ) eat ( ounces int ) string { return fmt . Sprintf ( \"%v ate %v ounces, but it made no difference\" , b . name , ounces ) } func ( b blackHole ) poo ( ounces int ) string { return fmt . Sprintf ( \"%v tried to poo %v but nothing can escape\" , b . name , ounces ) } func feedAnimal ( a animal ) { fmt . Println ( a . eat ( 10 )) fmt . Println ( a . speak ()) } func main () { b := blackHole { name : \"Gargantua\" } feedAnimal ( b ) } A struct can have extra methods that aren't part of the interface and a struct can implement any number of interfaces. empty interface The empty interface type interface{} can be used to enable a function to take any value. All Go types satisfy the empty interface. fmt.Println is a variadic function that takes empty interfaces: fmt . Println ( 5 * 5 ) fmt . Println ( \"some string\" ) fmt . Println ( func () string { return \"hi\" }) fmt . Println ([] string { \"tree\" , \"shrub\" , \"bush\" , \"flower\" , \"leaf\" , \"root\" }) prints 25 some string 0x10910c0 [tree shrub bush flower leaf root] Empty interface values must be cast before they can be used as a specific type: func add ( a , b interface {}) interface {} { aval , aok := ( a ).( int ) bval , bok := ( b ).( int ) if aok && bok { return aval + bval } fmt . Printf ( \"%v ok: %v, %v ok: %v\\n\" , a , aok , b , bok ) return nil } func main () { fmt . Println ( add ( 5 , 4 )) fmt . Println ( add ( \"5\" , \"4\" )) fmt . Println ( add ( 5.5 , 4.4 )) fmt . Println ( add ( \"four\" , \"five\" )) } prints 9 5 ok: false, 4 ok: false <nil> 5.5 ok: false, 4.4 ok: false <nil> four ok: false, five ok: false <nil> If you recall from part 2, you can use switch to check the type of an interface and cast it to that type: var a interface {} b := 0 switch value := a .( type ) { case string : i , _ := strconv . Atoi ( value ) b += i case bool : b = - b case int : b += value default : fmt . Println ( \"unexpected type, b is unchanged\" ) } Hands on! In the repo, open the file ./intermediate/10interfaces.go Complete the TODOs Run make 10 from project root (alternatively, type go run ./10interfaces.go ) Example implementation available on solutions branch","title":"10 - Unlike a user interface, these take a bit of explanation"},{"location":"10interfaces/#interface","text":"An interface in Go is a collection of methods. Interface declaration is quite similar to structs except you list the methods that the interface has rather than properties. The interface method parameters and return types can be named. The names are optional but may add clarity to the interface. The following two interfaces are equivalent. type animal interface { speak () string eat ( int ) string poo ( int ) string } type animal interface { speak () ( message string ) eat ( ounces int ) ( message string ) poo ( ounces int ) ( message string ) } Any struct that implements all the methods of an interface is then considered as implementing that interface: type animal interface { speak () string eat ( int ) string poo ( int ) string } type dog struct { name string digestingFoodOunces int } func ( d dog ) speak () string { return \"rrrr RUFF!\" } func ( d * dog ) eat ( ounces int ) string { d . digestingFoodOunces += ounces return fmt . Sprintf ( \"%v ate and is now digesting %v ounces of food\" , d . name , d . digestingFoodOunces ) } func ( d * dog ) poo ( ounces int ) string { d . digestingFoodOunces -= ounces return fmt . Sprintf ( \"%v poo'd and is now digesting %v ounces of food\" , d . name , d . digestingFoodOunces ) } Using an interface as a parameter enables a function to accept any struct that implements the interface: func main () { d := dog { name : \"Ein\" } feedAnimal ( & d ) } func feedAnimal ( a animal ) { fmt . Println ( a . eat ( 10 )) fmt . Println ( a . speak ()) } Because eat() and poo() have a pointer receiver, only a pointer dog (the type, not the breed) satisfies the interface. The blackHole struct below only uses value receivers so it can be passed by value: type animal interface { speak () string eat ( int ) string poo ( int ) string } type blackHole struct { name string } func ( b blackHole ) speak () string { return \"...........\" } func ( b blackHole ) eat ( ounces int ) string { return fmt . Sprintf ( \"%v ate %v ounces, but it made no difference\" , b . name , ounces ) } func ( b blackHole ) poo ( ounces int ) string { return fmt . Sprintf ( \"%v tried to poo %v but nothing can escape\" , b . name , ounces ) } func feedAnimal ( a animal ) { fmt . Println ( a . eat ( 10 )) fmt . Println ( a . speak ()) } func main () { b := blackHole { name : \"Gargantua\" } feedAnimal ( b ) } A struct can have extra methods that aren't part of the interface and a struct can implement any number of interfaces.","title":"interface"},{"location":"10interfaces/#empty-interface","text":"The empty interface type interface{} can be used to enable a function to take any value. All Go types satisfy the empty interface. fmt.Println is a variadic function that takes empty interfaces: fmt . Println ( 5 * 5 ) fmt . Println ( \"some string\" ) fmt . Println ( func () string { return \"hi\" }) fmt . Println ([] string { \"tree\" , \"shrub\" , \"bush\" , \"flower\" , \"leaf\" , \"root\" }) prints 25 some string 0x10910c0 [tree shrub bush flower leaf root] Empty interface values must be cast before they can be used as a specific type: func add ( a , b interface {}) interface {} { aval , aok := ( a ).( int ) bval , bok := ( b ).( int ) if aok && bok { return aval + bval } fmt . Printf ( \"%v ok: %v, %v ok: %v\\n\" , a , aok , b , bok ) return nil } func main () { fmt . Println ( add ( 5 , 4 )) fmt . Println ( add ( \"5\" , \"4\" )) fmt . Println ( add ( 5.5 , 4.4 )) fmt . Println ( add ( \"four\" , \"five\" )) } prints 9 5 ok: false, 4 ok: false <nil> 5.5 ok: false, 4.4 ok: false <nil> four ok: false, five ok: false <nil> If you recall from part 2, you can use switch to check the type of an interface and cast it to that type: var a interface {} b := 0 switch value := a .( type ) { case string : i , _ := strconv . Atoi ( value ) b += i case bool : b = - b case int : b += value default : fmt . Println ( \"unexpected type, b is unchanged\" ) }","title":"empty interface"},{"location":"10interfaces/#hands-on","text":"In the repo, open the file ./intermediate/10interfaces.go Complete the TODOs Run make 10 from project root (alternatively, type go run ./10interfaces.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"11goroutines/","text":"Covered in this module: goroutines goroutines So far, all the function calls that have been shown are done synchronously. To call a function so that it runs concurrently to the invoker, use the go keyword: package main import ( \"fmt\" \"time\" ) func main () { go repeat ( \"Pete\" , 3 ) repeat ( \"Repeat\" , 5 ) time . Sleep ( time . Millisecond * 10 ) } func repeat ( str string , times int ) { for i := 0 ; i < times ; i ++ { fmt . Println ( str , i ) time . Sleep ( time . Microsecond * 5 ) } } prints Repeat 0 Repeat 1 Pete 0 Pete 1 Repeat 2 Pete 2 Repeat 3 Repeat 4 Note Your program will not wait for your goroutines to complete before closing. Once the goroutine that main is running on (usually refered to as the main routine) closes the app will close as well. Only functions with no return values are eligible to be goroutines. There are no such restrictions on goroutine function parameters. You will likely see a different pattern of printed strings each time you run the repeat example function above. Go handles all the logic for spreading work and swapping routines on CPU threads for you, so you can spin up many goroutines without necessarily needing to think about how the work might be accomplished. func main () { go ticker ( 100 ) go ticker ( 250 ) go ticker ( 333 ) go ticker ( 500 ) time . Sleep ( time . Millisecond * 1050 ) } func ticker ( waitMs int ) { for i := 1 ; i <= 1000 / waitMs ; i ++ { time . Sleep ( time . Millisecond * time . Duration ( waitMs )) fmt . Printf ( \"%v, \" , waitMs * i ) } fmt . Println () } prints 100, 200, 250, 300, 333, 400, 500, 500, 500, 600, 666, 700, 750, 800, 900, 1000, 1000, 999, 1000, Note Go has a ticker implementation in the native package time (created by time.NewTicker() ). The ticker above is just for teaching purposes. You cannot return a value from goroutine directly, but go offers a construct called channel for communicating between goroutines that will be covered in the next module. Hands on! In the repo, open the file ./intermediate/11goroutines.go Complete the TODOs Run make 11 from project root (alternatively, type go run ./11goroutines.go ) Example implementation available on solutions branch","title":"11 - Getting into the routine"},{"location":"11goroutines/#goroutines","text":"So far, all the function calls that have been shown are done synchronously. To call a function so that it runs concurrently to the invoker, use the go keyword: package main import ( \"fmt\" \"time\" ) func main () { go repeat ( \"Pete\" , 3 ) repeat ( \"Repeat\" , 5 ) time . Sleep ( time . Millisecond * 10 ) } func repeat ( str string , times int ) { for i := 0 ; i < times ; i ++ { fmt . Println ( str , i ) time . Sleep ( time . Microsecond * 5 ) } } prints Repeat 0 Repeat 1 Pete 0 Pete 1 Repeat 2 Pete 2 Repeat 3 Repeat 4 Note Your program will not wait for your goroutines to complete before closing. Once the goroutine that main is running on (usually refered to as the main routine) closes the app will close as well. Only functions with no return values are eligible to be goroutines. There are no such restrictions on goroutine function parameters. You will likely see a different pattern of printed strings each time you run the repeat example function above. Go handles all the logic for spreading work and swapping routines on CPU threads for you, so you can spin up many goroutines without necessarily needing to think about how the work might be accomplished. func main () { go ticker ( 100 ) go ticker ( 250 ) go ticker ( 333 ) go ticker ( 500 ) time . Sleep ( time . Millisecond * 1050 ) } func ticker ( waitMs int ) { for i := 1 ; i <= 1000 / waitMs ; i ++ { time . Sleep ( time . Millisecond * time . Duration ( waitMs )) fmt . Printf ( \"%v, \" , waitMs * i ) } fmt . Println () } prints 100, 200, 250, 300, 333, 400, 500, 500, 500, 600, 666, 700, 750, 800, 900, 1000, 1000, 999, 1000, Note Go has a ticker implementation in the native package time (created by time.NewTicker() ). The ticker above is just for teaching purposes. You cannot return a value from goroutine directly, but go offers a construct called channel for communicating between goroutines that will be covered in the next module.","title":"goroutines"},{"location":"11goroutines/#hands-on","text":"In the repo, open the file ./intermediate/11goroutines.go Complete the TODOs Run make 11 from project root (alternatively, type go run ./11goroutines.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"12channels/","text":"Covered in this module: channels channels Channels are mono-directional pipes that goroutines can use to communicate. To create a channel use make(chan <type>) where type is the type of the values that will be passed in the channel. To send a value to a channel you use the syntax channel <- value . To receive a value from a channel, use <-channel and capture the retrieved value into a variable like variable := <-channel : func main () { randInts := make ( chan int ) go roll1d6 ( randInts ) roll := <- randInts // this pulls new rolls from the channel fmt . Println ( \"You rolled a\" , roll ) } func roll1d6 ( c chan int ) { c <- rand . Intn ( 6 ) + 1 // this passes new rolls into the channel } If you are just using the channel as a ping mechanism (i.e. you don't care about the value in the channel), you can receive with simply <-channel without capturing the retrieved value. func main () { ping := make ( chan bool ) startTime := time . Now () go waitForPing ( ping ) <- ping fmt . Println ( \"Program took\" , time . Since ( startTime )) } func waitForPing ( c chan bool ) { time . Sleep ( time . Second * 1 ) c <- true } prints Program took 1.00006811s Send and receive on channels are both blocking. Go will block the enclosing goroutine until both sides of the channel are ready. You can specify whether a channel is to be used for sending or receiving as part of the function parameter list: func main () { randInts := make ( chan int ) done := make ( chan bool ) go roll1d6 ( randInts ) go printRoll ( randInts , done ) <- done } func roll1d6 ( c chan <- int ) { c <- rand . Intn ( 6 ) + 1 } func printRoll ( c <- chan int , done chan <- bool ) { fmt . Println ( \"You rolled a\" , <- c ) done <- true } A channel can have any number of senders and receivers. A value going into a channel is guaranteed to be received by only one receiver. Hands on! In the repo, open the file ./intermediate/12channels.go Complete the TODOs Run make 12 from project root (alternatively, type go run ./12channels.go ) Example implementation available on solutions branch","title":"12 - Now you're thinking with channels"},{"location":"12channels/#channels","text":"Channels are mono-directional pipes that goroutines can use to communicate. To create a channel use make(chan <type>) where type is the type of the values that will be passed in the channel. To send a value to a channel you use the syntax channel <- value . To receive a value from a channel, use <-channel and capture the retrieved value into a variable like variable := <-channel : func main () { randInts := make ( chan int ) go roll1d6 ( randInts ) roll := <- randInts // this pulls new rolls from the channel fmt . Println ( \"You rolled a\" , roll ) } func roll1d6 ( c chan int ) { c <- rand . Intn ( 6 ) + 1 // this passes new rolls into the channel } If you are just using the channel as a ping mechanism (i.e. you don't care about the value in the channel), you can receive with simply <-channel without capturing the retrieved value. func main () { ping := make ( chan bool ) startTime := time . Now () go waitForPing ( ping ) <- ping fmt . Println ( \"Program took\" , time . Since ( startTime )) } func waitForPing ( c chan bool ) { time . Sleep ( time . Second * 1 ) c <- true } prints Program took 1.00006811s Send and receive on channels are both blocking. Go will block the enclosing goroutine until both sides of the channel are ready. You can specify whether a channel is to be used for sending or receiving as part of the function parameter list: func main () { randInts := make ( chan int ) done := make ( chan bool ) go roll1d6 ( randInts ) go printRoll ( randInts , done ) <- done } func roll1d6 ( c chan <- int ) { c <- rand . Intn ( 6 ) + 1 } func printRoll ( c <- chan int , done chan <- bool ) { fmt . Println ( \"You rolled a\" , <- c ) done <- true } A channel can have any number of senders and receivers. A value going into a channel is guaranteed to be received by only one receiver.","title":"channels"},{"location":"12channels/#hands-on","text":"In the repo, open the file ./intermediate/12channels.go Complete the TODOs Run make 12 from project root (alternatively, type go run ./12channels.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"13currying/","text":"Covered in this module: anonymous functions closures currying recursion anonymous functions Go supports anonymous functions that can be passed around like any other value. func main () { add := func ( a , b int ) int { return a + b } fmt . Println ( add ( 3 , 400 )) fmt . Println ( add ( 10 , 59 )) fmt . Println ( add ( - 5 , 252 )) fmt . Println ( add ( 80 , - 311 )) fmt . Println ( add ( - 123 , 42 )) fmt . Println ( add ( 0 , - 65 )) } prints 403 69 247 -231 -81 -65 currying Functions can return a function to allow for currying. The function returned by sequence() is considered a closure since it encapsulates the sequence value. The returned function essentially takes ownership of the seq variable. func sequence ( startingVal int ) func () int { seq := startingVal return func () int { seq ++ return seq } } func main () { nextVal := sequence ( 25 ) fmt . Println ( nextVal ()) fmt . Println ( nextVal ()) fmt . Println ( nextVal ()) fmt . Println ( nextVal ()) moreVal := sequence ( 0 ) fmt . Println ( moreVal ()) fmt . Println ( moreVal ()) } prints 26 27 28 29 1 2 recursion Functions can also invoke themselves, allowing for recursive behavior. package main import ( \"errors\" \"fmt\" \"math/rand\" \"time\" ) func mockCall () ( int , error ) { num := rand . Intn ( 10 ) if num <= 5 { return num , errors . New ( \"call failed\" ) } return num , nil } func attemptCall ( call func () ( int , error ), maxRetries , try int ) int { result , err := call () if err != nil { if try >= maxRetries { fmt . Printf ( \"call failed after %v attempts. last error is: %v\\n\" , maxRetries , err . Error ()) return 0 } return attemptCall ( call , maxRetries , try + 1 ) } return result } func main () { rand . Seed ( time . Now (). UTC (). UnixNano ()) result := attemptCall ( mockCall , 3 , 1 ) fmt . Println ( \"Result is\" , result ) } occasionally prints call failed after 3 attempts. last error is call failed Result is 0 Hands on! In the repo, open the file ./advanced/13currying.go Complete the TODOs Run make 13 from project root (alternatively, type go run ./13currying.go ) Example implementation available on solutions branch","title":"13 - Staying anonymous"},{"location":"13currying/#anonymous-functions","text":"Go supports anonymous functions that can be passed around like any other value. func main () { add := func ( a , b int ) int { return a + b } fmt . Println ( add ( 3 , 400 )) fmt . Println ( add ( 10 , 59 )) fmt . Println ( add ( - 5 , 252 )) fmt . Println ( add ( 80 , - 311 )) fmt . Println ( add ( - 123 , 42 )) fmt . Println ( add ( 0 , - 65 )) } prints 403 69 247 -231 -81 -65","title":"anonymous functions"},{"location":"13currying/#currying","text":"Functions can return a function to allow for currying. The function returned by sequence() is considered a closure since it encapsulates the sequence value. The returned function essentially takes ownership of the seq variable. func sequence ( startingVal int ) func () int { seq := startingVal return func () int { seq ++ return seq } } func main () { nextVal := sequence ( 25 ) fmt . Println ( nextVal ()) fmt . Println ( nextVal ()) fmt . Println ( nextVal ()) fmt . Println ( nextVal ()) moreVal := sequence ( 0 ) fmt . Println ( moreVal ()) fmt . Println ( moreVal ()) } prints 26 27 28 29 1 2","title":"currying"},{"location":"13currying/#recursion","text":"Functions can also invoke themselves, allowing for recursive behavior. package main import ( \"errors\" \"fmt\" \"math/rand\" \"time\" ) func mockCall () ( int , error ) { num := rand . Intn ( 10 ) if num <= 5 { return num , errors . New ( \"call failed\" ) } return num , nil } func attemptCall ( call func () ( int , error ), maxRetries , try int ) int { result , err := call () if err != nil { if try >= maxRetries { fmt . Printf ( \"call failed after %v attempts. last error is: %v\\n\" , maxRetries , err . Error ()) return 0 } return attemptCall ( call , maxRetries , try + 1 ) } return result } func main () { rand . Seed ( time . Now (). UTC (). UnixNano ()) result := attemptCall ( mockCall , 3 , 1 ) fmt . Println ( \"Result is\" , result ) } occasionally prints call failed after 3 attempts. last error is call failed Result is 0","title":"recursion"},{"location":"13currying/#hands-on","text":"In the repo, open the file ./advanced/13currying.go Complete the TODOs Run make 13 from project root (alternatively, type go run ./13currying.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"14async/","text":"Covered in this module: buffered channels select non-blocking channels close buffered channels As discussed in Part 12 , channels by default are synchronous in that they require that both sender and receiver are ready before the value is sent across the channel. Channels can be buffered to enable values to be sent into the channel without a ready receiver. func main () { buffered := make ( chan string , 3 ) buffered <- \"first\" buffered <- \"second\" buffered <- \"third\" fmt . Println ( <- buffered ) fmt . Println ( <- buffered ) fmt . Println ( <- buffered ) } prints first second third However, once the buffered channel is full, any new send will block until the channel has space. func main () { buffered := make ( chan string , 2 ) // decrease buffer to 2 buffered <- \"first\" buffered <- \"second\" buffered <- \"third\" // this is now blocking fmt . Println ( <- buffered ) fmt . Println ( <- buffered ) fmt . Println ( <- buffered ) } select Select allows your routine to listen to several channels simultaneously and shares syntax with switch except that each case monitors a channel: func waitToRespond ( waitTimeMs time . Duration , response string , respond chan <- string ) { time . Sleep ( time . Millisecond * waitTimeMs ) respond <- response } func main () { chan1 := make ( chan string ) chan2 := make ( chan string ) go waitToRespond ( 500 , \"first\" , chan1 ) go waitToRespond ( 250 , \"second\" , chan2 ) for i := 0 ; i < 2 ; i ++ { select { case res := <- chan1 : fmt . Println ( res ) case res := <- chan2 : fmt . Println ( res ) } } } prints second first Note If two or more channels have messages ready to be received by a single select , one case is chosen at random. non-blocking channels The select example above behaves in a synchronous manner as it will block until one of its cases is resolved. Adding a default case to the select will make it non-blocking: func waitToRespond ( waitTimeMs time . Duration , response string , respond chan <- string ) { time . Sleep ( time . Millisecond * waitTimeMs ) respond <- response } func main () { chan1 := make ( chan string ) chan2 := make ( chan string ) go waitToRespond ( 500 , \"first\" , chan1 ) go waitToRespond ( 250 , \"second\" , chan2 ) var i int for i < 2 { select { case res := <- chan1 : fmt . Println ( res ) i ++ case res := <- chan2 : fmt . Println ( res ) i ++ default : fmt . Println ( \"nothing. waiting 50ms\" ) time . Sleep ( time . Millisecond * 50 ) } } } prints nothing. waiting 50ms nothing. waiting 50ms nothing. waiting 50ms nothing. waiting 50ms nothing. waiting 50ms second nothing. waiting 50ms nothing. waiting 50ms nothing. waiting 50ms nothing. waiting 50ms nothing. waiting 50ms first Note For cases where you need a looping select , it is recommended to omit a default case unless your default is putting the loop to sleep for a period of time. select does a lazy block whereas for will continue to hog CPU. close After your routine is done writing to a channel, it can close the channel to indicate to the receiver that no more items will be sent. The convention is that only the writer/sender should close a channel; this is enforced by there being no way to tell whether a channel is closed on the send end. func ping ( tick chan <- time . Time ) { ticker := time . NewTicker ( time . Millisecond * 250 ) defer ticker . Stop () for i := 0 ; i < 4 ; i ++ { tick <- <- ticker . C } close ( tick ) } func main () { tick := make ( chan time . Time , 4 ) go ping ( tick ) time . Sleep ( time . Millisecond * 1050 ) for t := range tick { fmt . Println ( \"tick\" , t ) } } prints tick 2019-02-22 14:48:28.680445 -0500 EST m=+0.255451520 tick 2019-02-22 14:48:28.929341 -0500 EST m=+0.504354086 tick 2019-02-22 14:48:29.180488 -0500 EST m=+0.755507241 tick 2019-02-22 14:48:29.425965 -0500 EST m=+1.000990704 You can check if a channel is open on the receiver end by capturing two values on the receive. The first value will be the received item and the second is a boolean which is true if the channel is open. func ping ( tick chan <- time . Time ) { ticker := time . NewTicker ( time . Millisecond * 250 ) defer ticker . Stop () for i := 0 ; i < 4 ; i ++ { tick <- <- ticker . C } close ( tick ) } func main () { tick := make ( chan time . Time , 4 ) go ping ( tick ) for { t , open := <- tick if open { fmt . Println ( \"tick\" , t ) } else { break } } } prints tick 2019-02-22 14:49:24.685916 -0500 EST m=+0.251246062 tick 2019-02-22 14:49:24.936428 -0500 EST m=+0.501765172 tick 2019-02-22 14:49:25.188174 -0500 EST m=+0.753517292 tick 2019-02-22 14:49:25.43667 -0500 EST m=+1.002020070 Note The close signal takes up a spot in a buffered channel, so the close will block if there is no room in the channel. close works for both buffered and unbuffered channels and is a permanent state. Reading from a closed channel will continue to return false for its second value in perpetuity. You can not 'unclose' a channel. Also, attempting to send a value to a closed channel causes a panic. If you have multiple senders for a single channel, take care to make sure all senders are done before closing the channel. If you close the channel too early, an active sender routine will trigger a panic. For buffered channels, any values put in the channel prior to the close will still be delivered in the order they were sent before the close signal will be received. It is not required to close a channel. Channels can be used indefinitely or reinitialized as needed. close is just another way to signal between goroutines. Hands on! In the repo, open the file ./advanced/14async.go Complete the TODOs Run make 14 from project root (alternatively, type go run ./14async.go ) Example implementation available on solutions branch","title":"14 - Getting out of sync"},{"location":"14async/#buffered-channels","text":"As discussed in Part 12 , channels by default are synchronous in that they require that both sender and receiver are ready before the value is sent across the channel. Channels can be buffered to enable values to be sent into the channel without a ready receiver. func main () { buffered := make ( chan string , 3 ) buffered <- \"first\" buffered <- \"second\" buffered <- \"third\" fmt . Println ( <- buffered ) fmt . Println ( <- buffered ) fmt . Println ( <- buffered ) } prints first second third However, once the buffered channel is full, any new send will block until the channel has space. func main () { buffered := make ( chan string , 2 ) // decrease buffer to 2 buffered <- \"first\" buffered <- \"second\" buffered <- \"third\" // this is now blocking fmt . Println ( <- buffered ) fmt . Println ( <- buffered ) fmt . Println ( <- buffered ) }","title":"buffered channels"},{"location":"14async/#select","text":"Select allows your routine to listen to several channels simultaneously and shares syntax with switch except that each case monitors a channel: func waitToRespond ( waitTimeMs time . Duration , response string , respond chan <- string ) { time . Sleep ( time . Millisecond * waitTimeMs ) respond <- response } func main () { chan1 := make ( chan string ) chan2 := make ( chan string ) go waitToRespond ( 500 , \"first\" , chan1 ) go waitToRespond ( 250 , \"second\" , chan2 ) for i := 0 ; i < 2 ; i ++ { select { case res := <- chan1 : fmt . Println ( res ) case res := <- chan2 : fmt . Println ( res ) } } } prints second first Note If two or more channels have messages ready to be received by a single select , one case is chosen at random.","title":"select"},{"location":"14async/#non-blocking-channels","text":"The select example above behaves in a synchronous manner as it will block until one of its cases is resolved. Adding a default case to the select will make it non-blocking: func waitToRespond ( waitTimeMs time . Duration , response string , respond chan <- string ) { time . Sleep ( time . Millisecond * waitTimeMs ) respond <- response } func main () { chan1 := make ( chan string ) chan2 := make ( chan string ) go waitToRespond ( 500 , \"first\" , chan1 ) go waitToRespond ( 250 , \"second\" , chan2 ) var i int for i < 2 { select { case res := <- chan1 : fmt . Println ( res ) i ++ case res := <- chan2 : fmt . Println ( res ) i ++ default : fmt . Println ( \"nothing. waiting 50ms\" ) time . Sleep ( time . Millisecond * 50 ) } } } prints nothing. waiting 50ms nothing. waiting 50ms nothing. waiting 50ms nothing. waiting 50ms nothing. waiting 50ms second nothing. waiting 50ms nothing. waiting 50ms nothing. waiting 50ms nothing. waiting 50ms nothing. waiting 50ms first Note For cases where you need a looping select , it is recommended to omit a default case unless your default is putting the loop to sleep for a period of time. select does a lazy block whereas for will continue to hog CPU.","title":"non-blocking channels"},{"location":"14async/#close","text":"After your routine is done writing to a channel, it can close the channel to indicate to the receiver that no more items will be sent. The convention is that only the writer/sender should close a channel; this is enforced by there being no way to tell whether a channel is closed on the send end. func ping ( tick chan <- time . Time ) { ticker := time . NewTicker ( time . Millisecond * 250 ) defer ticker . Stop () for i := 0 ; i < 4 ; i ++ { tick <- <- ticker . C } close ( tick ) } func main () { tick := make ( chan time . Time , 4 ) go ping ( tick ) time . Sleep ( time . Millisecond * 1050 ) for t := range tick { fmt . Println ( \"tick\" , t ) } } prints tick 2019-02-22 14:48:28.680445 -0500 EST m=+0.255451520 tick 2019-02-22 14:48:28.929341 -0500 EST m=+0.504354086 tick 2019-02-22 14:48:29.180488 -0500 EST m=+0.755507241 tick 2019-02-22 14:48:29.425965 -0500 EST m=+1.000990704 You can check if a channel is open on the receiver end by capturing two values on the receive. The first value will be the received item and the second is a boolean which is true if the channel is open. func ping ( tick chan <- time . Time ) { ticker := time . NewTicker ( time . Millisecond * 250 ) defer ticker . Stop () for i := 0 ; i < 4 ; i ++ { tick <- <- ticker . C } close ( tick ) } func main () { tick := make ( chan time . Time , 4 ) go ping ( tick ) for { t , open := <- tick if open { fmt . Println ( \"tick\" , t ) } else { break } } } prints tick 2019-02-22 14:49:24.685916 -0500 EST m=+0.251246062 tick 2019-02-22 14:49:24.936428 -0500 EST m=+0.501765172 tick 2019-02-22 14:49:25.188174 -0500 EST m=+0.753517292 tick 2019-02-22 14:49:25.43667 -0500 EST m=+1.002020070 Note The close signal takes up a spot in a buffered channel, so the close will block if there is no room in the channel. close works for both buffered and unbuffered channels and is a permanent state. Reading from a closed channel will continue to return false for its second value in perpetuity. You can not 'unclose' a channel. Also, attempting to send a value to a closed channel causes a panic. If you have multiple senders for a single channel, take care to make sure all senders are done before closing the channel. If you close the channel too early, an active sender routine will trigger a panic. For buffered channels, any values put in the channel prior to the close will still be delivered in the order they were sent before the close signal will be received. It is not required to close a channel. Channels can be used indefinitely or reinitialized as needed. close is just another way to signal between goroutines.","title":"close"},{"location":"14async/#hands-on","text":"In the repo, open the file ./advanced/14async.go Complete the TODOs Run make 14 from project root (alternatively, type go run ./14async.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"15packages/","text":"Covered in this module: packages scope imports packages Packages allow you to group related code by domain, function, or other logical grouping. In practice, a package is a directory with one or more .go files. Packages are determined by the package declaration at the top of each file. You cannot have different package declarations in two .go files in the same directory. As you may have already noticed, you can call functions from other packages with the syntax package.Function . scope Scoping functions, values, and types is controlled simply by the casing on the first letter of the item. Capitalized items are visible and usable within the package they are declared in as well as any package that imports them. Lowercase items are only visible within the package they are declared and can be considered private . This can be very useful to control access to certain properties on your struct if you want them to be modifiable only by the struct's methods and not from the invoking package: type MyCoolStruct struct { internal string Value string } A common pattern is to provide a New() function that returns your struct that may contain hidden properties that were set as part of the creation. This allows you to encapsulate the logic for initializing your struct to your package rather than relying on the caller to do it properly: package caller type Caller struct { callCount int call func ( ... interface {}) ( interface {}, error ) } func ( d * Caller ) Call ( args ... interface {}) ( interface {}, error ) { d . callCount ++ return d . call ( args ) } func New ( call func ( ... interface {}) ( interface {}, error )) * Caller { return & Caller { call : call } } The above function can be invoked from another package as caller.New . Package and function names become important here. When naming your functions, keep the package name in mind and avoid unnecessary stuttering. New is preferable to NewCaller in this case as NewCaller would result in stuttering on invocation: caller.NewCaller() . imports You can import non-native Go libraries by specifying the repo location in the import declaration. package main import ( \"fmt\" \"github.com/sirupsen/logrus\" ) To make the library available within your codebase, use the command go get -u : go get -u github.com/sirupsen/logrus Go Modules are Go's built-in dependency management. They are not covered in-depth in this workshop but check out this tutorial to get started. Projects utilizing Go Modules (like this one) will have a go.mod and go.sum file at root. For those repos go get -u command will automatically add the dependency to your go.mod file. Just like packages within your project only uppercased functions, types, etc from the imported packages are accessible within your code. Hands on! In the repo, open the file ./advanced/15packages.go Complete the TODOs Run make 15 from project root (alternatively, type go run ./15packages.go ) Example implementation available on solutions branch","title":"15 - Here's your package"},{"location":"15packages/#packages","text":"Packages allow you to group related code by domain, function, or other logical grouping. In practice, a package is a directory with one or more .go files. Packages are determined by the package declaration at the top of each file. You cannot have different package declarations in two .go files in the same directory. As you may have already noticed, you can call functions from other packages with the syntax package.Function .","title":"packages"},{"location":"15packages/#scope","text":"Scoping functions, values, and types is controlled simply by the casing on the first letter of the item. Capitalized items are visible and usable within the package they are declared in as well as any package that imports them. Lowercase items are only visible within the package they are declared and can be considered private . This can be very useful to control access to certain properties on your struct if you want them to be modifiable only by the struct's methods and not from the invoking package: type MyCoolStruct struct { internal string Value string } A common pattern is to provide a New() function that returns your struct that may contain hidden properties that were set as part of the creation. This allows you to encapsulate the logic for initializing your struct to your package rather than relying on the caller to do it properly: package caller type Caller struct { callCount int call func ( ... interface {}) ( interface {}, error ) } func ( d * Caller ) Call ( args ... interface {}) ( interface {}, error ) { d . callCount ++ return d . call ( args ) } func New ( call func ( ... interface {}) ( interface {}, error )) * Caller { return & Caller { call : call } } The above function can be invoked from another package as caller.New . Package and function names become important here. When naming your functions, keep the package name in mind and avoid unnecessary stuttering. New is preferable to NewCaller in this case as NewCaller would result in stuttering on invocation: caller.NewCaller() .","title":"scope"},{"location":"15packages/#imports","text":"You can import non-native Go libraries by specifying the repo location in the import declaration. package main import ( \"fmt\" \"github.com/sirupsen/logrus\" ) To make the library available within your codebase, use the command go get -u : go get -u github.com/sirupsen/logrus Go Modules are Go's built-in dependency management. They are not covered in-depth in this workshop but check out this tutorial to get started. Projects utilizing Go Modules (like this one) will have a go.mod and go.sum file at root. For those repos go get -u command will automatically add the dependency to your go.mod file. Just like packages within your project only uppercased functions, types, etc from the imported packages are accessible within your code.","title":"imports"},{"location":"15packages/#hands-on","text":"In the repo, open the file ./advanced/15packages.go Complete the TODOs Run make 15 from project root (alternatively, type go run ./15packages.go ) Example implementation available on solutions branch","title":"Hands on!"},{"location":"16context/","text":"Covered in this module: context strconv context A common first parameter you will see for many functions is context often abbreviated to ctx . Context is a mechanism to pass cancellation signals and deadlines, and can also pass values scoped to some portion of the application (such as a module, individual request, etc). A context will either be context.Background() which is the base level context, or will be a child of the context.Background() created via functions like context.WithCancel() or context.WithDeadline() . package main import ( \"context\" \"fmt\" \"time\" ) func main () { reportCount := make ( chan int ) ctx , cancel := context . WithCancel ( context . Background ()) go worker ( ctx , reportCount ) time . Sleep ( time . Millisecond * 100 ) cancel () fmt . Println ( <- reportCount ) } func worker ( ctx context . Context , reportCount chan <- int ) { var count int for ctx . Err () == nil { count ++ } reportCount <- count } prints 4393918 You can use the cancel function to bail out of some unit of work, based on an error condition or another trigger. Deadlines and timeouts enable you can set a timeout on requests to dependencies scoped to an incoming request or some portion of your application. Context state can be access synchronously with ctx.Err() which returns an error, or asynchronously with ctx.Done() which returns a closed channel, when the context is cancelled or the deadline is reached. func worker ( ctx context . Context , increment <- chan bool ) ( count int ) { for { select { case <- ctx . Done (): return case <- increment : count ++ } } } Context signals are unidirectional. A cancelled context will also cancel any child context. You can use context to gracefully stop your application or prematurely stop calls to dependencies. However, you must use something like a channel or a waitgroup to receive done signals from your goroutines if you want to make sure all parts of your application are properly closed before stopping the app. strconv In a data-heavy application there are occasions where you will need to make conversions between various units. Go has several build in libraries built for converting and manipulating certain types. strconv contains functions like strconv.Atoi() and strconv.Itoa() for converting strings to integers and vice versa: package main import ( \"fmt\" \"strconv\" \"github.com/pkg/errors\" ) func main () { var str string str = strconv . Itoa ( 256 ) fmt . Println ( str ) var backsies int var err error backsies , err = strconv . Atoi ( str ) if err != nil { fmt . Println ( errors . Wrap ( err , \"Atoi conversion failed\" )) } fmt . Println ( backsies ) }","title":"16 - Taken out of context"},{"location":"16context/#context","text":"A common first parameter you will see for many functions is context often abbreviated to ctx . Context is a mechanism to pass cancellation signals and deadlines, and can also pass values scoped to some portion of the application (such as a module, individual request, etc). A context will either be context.Background() which is the base level context, or will be a child of the context.Background() created via functions like context.WithCancel() or context.WithDeadline() . package main import ( \"context\" \"fmt\" \"time\" ) func main () { reportCount := make ( chan int ) ctx , cancel := context . WithCancel ( context . Background ()) go worker ( ctx , reportCount ) time . Sleep ( time . Millisecond * 100 ) cancel () fmt . Println ( <- reportCount ) } func worker ( ctx context . Context , reportCount chan <- int ) { var count int for ctx . Err () == nil { count ++ } reportCount <- count } prints 4393918 You can use the cancel function to bail out of some unit of work, based on an error condition or another trigger. Deadlines and timeouts enable you can set a timeout on requests to dependencies scoped to an incoming request or some portion of your application. Context state can be access synchronously with ctx.Err() which returns an error, or asynchronously with ctx.Done() which returns a closed channel, when the context is cancelled or the deadline is reached. func worker ( ctx context . Context , increment <- chan bool ) ( count int ) { for { select { case <- ctx . Done (): return case <- increment : count ++ } } } Context signals are unidirectional. A cancelled context will also cancel any child context. You can use context to gracefully stop your application or prematurely stop calls to dependencies. However, you must use something like a channel or a waitgroup to receive done signals from your goroutines if you want to make sure all parts of your application are properly closed before stopping the app.","title":"context"},{"location":"16context/#strconv","text":"In a data-heavy application there are occasions where you will need to make conversions between various units. Go has several build in libraries built for converting and manipulating certain types. strconv contains functions like strconv.Atoi() and strconv.Itoa() for converting strings to integers and vice versa: package main import ( \"fmt\" \"strconv\" \"github.com/pkg/errors\" ) func main () { var str string str = strconv . Itoa ( 256 ) fmt . Println ( str ) var backsies int var err error backsies , err = strconv . Atoi ( str ) if err != nil { fmt . Println ( errors . Wrap ( err , \"Atoi conversion failed\" )) } fmt . Println ( backsies ) }","title":"strconv"},{"location":"introduction/","text":"A brief history of Go Began life at Google and is widely used there. Conceived in 2007, publicly announced 2009, and v1 was released in 2012 Designers cited their dislike of C++ as a primary motivation for designing Go Core tenets Compiled - Go compiles to a binary that can run on all common operating systems. Concurrency-forward - Go handles the heavy lifting for matching routines to threads. You get to focus on the logic. Object-oriented/imperative - While you can apply many functional concepts here, Go is unabashedly object-oriented. Statically-typed - Everything has a type! I C what you did there Go takes its cues from C, Python, and Java; but adopted patterns from dynamically typed languages: type inference semicolons are inferred fast compilation remote package management and online documentation Already ready already Robust native tooling Built-in concurrency primitives Language provides tools for building, formatting, running, documenting, etc Native unit testing library (though supplementing it is recommended) Built-in dependency management Upsides Easy to learn Large, excited community Simple concurrency Robust plug-ins for most popular IDEs FUN Downsides Unit testing with mocks has a learning curve Error handling may be bulky for some Concurrency is easy to learn, difficult to master","title":"Introduction"},{"location":"introduction/#a-brief-history-of-go","text":"Began life at Google and is widely used there. Conceived in 2007, publicly announced 2009, and v1 was released in 2012 Designers cited their dislike of C++ as a primary motivation for designing Go","title":"A brief history of Go"},{"location":"introduction/#core-tenets","text":"Compiled - Go compiles to a binary that can run on all common operating systems. Concurrency-forward - Go handles the heavy lifting for matching routines to threads. You get to focus on the logic. Object-oriented/imperative - While you can apply many functional concepts here, Go is unabashedly object-oriented. Statically-typed - Everything has a type!","title":"Core tenets"},{"location":"introduction/#i-c-what-you-did-there","text":"Go takes its cues from C, Python, and Java; but adopted patterns from dynamically typed languages: type inference semicolons are inferred fast compilation remote package management and online documentation","title":"I C what you did there"},{"location":"introduction/#already-ready-already","text":"Robust native tooling Built-in concurrency primitives Language provides tools for building, formatting, running, documenting, etc Native unit testing library (though supplementing it is recommended) Built-in dependency management","title":"Already ready already"},{"location":"introduction/#upsides","text":"Easy to learn Large, excited community Simple concurrency Robust plug-ins for most popular IDEs FUN","title":"Upsides"},{"location":"introduction/#downsides","text":"Unit testing with mocks has a learning curve Error handling may be bulky for some Concurrency is easy to learn, difficult to master","title":"Downsides"}]}